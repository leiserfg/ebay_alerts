/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * eBay Alerts Api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import {Configuration} from './configuration'

const BASE_PATH = 'http://localhost:8000/api'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface Alert
 */
export interface Alert {
  /**
   *
   * @type {string}
   * @memberof Alert
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Alert
   */
  owner?: string
  /**
   *
   * @type {string}
   * @memberof Alert
   */
  frequencyName?: string
  /**
   *
   * @type {string}
   * @memberof Alert
   */
  search_terms: string
  /**
   *
   * @type {number}
   * @memberof Alert
   */
  frequency?: number
  /**
   *
   * @type {boolean}
   * @memberof Alert
   */
  enabled?: boolean
}

/**
 *
 * @export
 * @interface CreateAlert
 */
export interface CreateAlert {
  /**
   *
   * @type {string}
   * @memberof CreateAlert
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof CreateAlert
   */
  search_terms: string
  /**
   *
   * @type {number}
   * @memberof CreateAlert
   */
  frequency?: number
  /**
   *
   * @type {string}
   * @memberof CreateAlert
   */
  frequencyName?: string
}

/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Customer
   */
  email: string
}

/**
 * AlertsApi - fetch parameter creator
 * @export
 */
export const AlertsApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {CreateAlert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsCreate(data: CreateAlert, options: any = {}): FetchArgs {
      // verify required parameter 'data' is not null or undefined
      if (data === null || data === undefined) {
        throw new RequiredError(
          'data',
          'Required parameter data was null or undefined when calling alertsCreate.'
        )
      }
      const localVarPath = `/alerts/`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'POST'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = JSON.stringify(data || {})

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsDelete(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling alertsDelete.'
        )
      }
      const localVarPath = `/alerts/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} [owner] Owner of the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsList(owner?: string, options: any = {}): FetchArgs {
      const localVarPath = `/alerts/`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'GET'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} id
     * @param {Alert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsPartialUpdate(id: string, data: Alert, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling alertsPartialUpdate.'
        )
      }
      // verify required parameter 'data' is not null or undefined
      if (data === null || data === undefined) {
        throw new RequiredError(
          'data',
          'Required parameter data was null or undefined when calling alertsPartialUpdate.'
        )
      }
      const localVarPath = `/alerts/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'PATCH'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = JSON.stringify(data || {})

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsRead(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling alertsRead.'
        )
      }
      const localVarPath = `/alerts/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'GET'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsSuscribe(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling alertsSuscribe.'
        )
      }
      const localVarPath = `/alerts/{id}/suscribe/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'GET'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsUnsuscribe(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling alertsUnsuscribe.'
        )
      }
      const localVarPath = `/alerts/{id}/unsuscribe/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'GET'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @param {string} id
     * @param {Alert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsUpdate(id: string, data: Alert, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling alertsUpdate.'
        )
      }
      // verify required parameter 'data' is not null or undefined
      if (data === null || data === undefined) {
        throw new RequiredError(
          'data',
          'Required parameter data was null or undefined when calling alertsUpdate.'
        )
      }
      const localVarPath = `/alerts/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'PUT'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = JSON.stringify(data || {})

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {CreateAlert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsCreate(
      data: CreateAlert,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateAlert> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsCreate(data, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsDelete(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsDelete(id, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} [owner] Owner of the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsList(
      owner?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Alert>> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsList(owner, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} id
     * @param {Alert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsPartialUpdate(
      id: string,
      data: Alert,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Alert> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsPartialUpdate(id, data, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsRead(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Alert> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsRead(id, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsSuscribe(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Alert> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsSuscribe(id, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsUnsuscribe(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsUnsuscribe(id, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @param {string} id
     * @param {Alert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsUpdate(
      id: string,
      data: Alert,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Alert> {
      const localVarFetchArgs = AlertsApiFetchParamCreator(
        configuration
      ).alertsUpdate(id, data, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {CreateAlert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsCreate(data: CreateAlert, options?: any) {
      return AlertsApiFp(configuration).alertsCreate(data, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsDelete(id: string, options?: any) {
      return AlertsApiFp(configuration).alertsDelete(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @param {string} [owner] Owner of the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsList(owner?: string, options?: any) {
      return AlertsApiFp(configuration).alertsList(owner, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @param {string} id
     * @param {Alert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsPartialUpdate(id: string, data: Alert, options?: any) {
      return AlertsApiFp(configuration).alertsPartialUpdate(id, data, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsRead(id: string, options?: any) {
      return AlertsApiFp(configuration).alertsRead(id, options)(fetch, basePath)
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsSuscribe(id: string, options?: any) {
      return AlertsApiFp(configuration).alertsSuscribe(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsUnsuscribe(id: string, options?: any) {
      return AlertsApiFp(configuration).alertsUnsuscribe(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @param {string} id
     * @param {Alert} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsUpdate(id: string, data: Alert, options?: any) {
      return AlertsApiFp(configuration).alertsUpdate(id, data, options)(
        fetch,
        basePath
      )
    }
  }
}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
  /**
   *
   * @param {} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsCreate(data: CreateAlert, options?: any) {
    return AlertsApiFp(this.configuration).alertsCreate(data, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @param {} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsDelete(id: string, options?: any) {
    return AlertsApiFp(this.configuration).alertsDelete(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @param {} [owner] Owner of the alert
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsList(owner?: string, options?: any) {
    return AlertsApiFp(this.configuration).alertsList(owner, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @param {} id
   * @param {} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsPartialUpdate(id: string, data: Alert, options?: any) {
    return AlertsApiFp(this.configuration).alertsPartialUpdate(
      id,
      data,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsRead(id: string, options?: any) {
    return AlertsApiFp(this.configuration).alertsRead(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @param {} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsSuscribe(id: string, options?: any) {
    return AlertsApiFp(this.configuration).alertsSuscribe(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @param {} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsUnsuscribe(id: string, options?: any) {
    return AlertsApiFp(this.configuration).alertsUnsuscribe(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @param {} id
   * @param {} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public alertsUpdate(id: string, data: Alert, options?: any) {
    return AlertsApiFp(this.configuration).alertsUpdate(id, data, options)(
      this.fetch,
      this.basePath
    )
  }
}

/**
 * CustomersApi - fetch parameter creator
 * @export
 */
export const CustomersApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} id A UUID string identifying this customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersRead(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling customersRead.'
        )
      }
      const localVarPath = `/customers/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({method: 'GET'}, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' + btoa(configuration.username + ':' + configuration.password)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} id A UUID string identifying this customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersRead(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
      const localVarFetchArgs = CustomersApiFetchParamCreator(
        configuration
      ).customersRead(id, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} id A UUID string identifying this customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersRead(id: string, options?: any) {
      return CustomersApiFp(configuration).customersRead(id, options)(
        fetch,
        basePath
      )
    }
  }
}

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
  /**
   *
   * @param {} id A UUID string identifying this customer.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomersApi
   */
  public customersRead(id: string, options?: any) {
    return CustomersApiFp(this.configuration).customersRead(id, options)(
      this.fetch,
      this.basePath
    )
  }
}
